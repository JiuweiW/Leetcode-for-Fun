[1000](https://leetcode.com/problems/minimum-cost-to-merge-stones/) Minimum Cost to Merge Stones


```python
# dp[i][j][m] means the cost needed to merge stone[i] ~ stones[j] into m piles.
# Initial status dp[i][i][1] = 0 and dp[i][i][m] = infinity
# dp[i][j][m] = min(dp[i][mid][1] + dp[mid + 1][j][m - 1] + stonesNumber[i][j])
class Solution:
    def mergeStones(self, stones: List[int], K: int) -> int:
        N = len(stones)
        if (N - 1) % (K - 1): 
            return -1
        INF = float('inf')
        memo = {}
        prefix = [0] # prefix sum
        for x in stones:
            prefix.append(prefix[-1] + x)

        def dp(i, j, m):
            if (j - i + 1 - m) % (K - 1): 
                return INF  # optimize
            if (i, j, m) in memo:
                return memo[i, j, m]
            if i == j:
                res = 0 if m == 1 else INF
            else:
                if m == 1:
                    res = dp(i, j, K) + prefix[j + 1] - prefix[i]
                else:
                    res = INF
                    for mid in range(i, j, K - 1):
                        res = min(res, dp(i, mid, 1) + dp(mid + 1, j, m - 1))
            memo[i, j, m] = res
            return res
        res = dp(0, N - 1, 1)
        return res if res < INF else 0
```